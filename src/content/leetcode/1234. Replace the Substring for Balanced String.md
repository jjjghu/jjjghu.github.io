---
category: "leetcode"

title: "1234. 替換子字串得到平衡字串"   
en_title: "1234. Replace the Substring for Balanced String"

problem_id: "1234"
difficulty: "medium"
tags: ["string", "sliding window"]

link: "https://leetcode.cn/problems/replace-the-substring-for-balanced-string/"
en_link: "https://leetcode.com/problems/replace-the-substring-for-balanced-string/"
date: "2025-08-09"
---
推薦事前閱讀：[滑動窗口](https://gjplieqszy7.sg.larksuite.com/wiki/KJC1wRJAqidzAqkpCEClyp2YgUf#share-YymRdz0sjo08TMxevnHlMbCEgDh)
## 思路
<table>
<tr>
<td valign="top" width="87%">

先計算每個字元出現了多少次，出現次數多餘 $n/4$ 的部分需要取代掉。\
比如說，現在要求每個字元出現 10 次，而 Q 出現了 12 次，這時就去找一個子字串，裡面要包含兩個 Q，把它替換掉。\
Q 佔走的位置會影響到其他字元，只要把找到的子字串換成缺少的字元就行了。以右邊例子而言就是換成 E 和 R。
</td>
<td>

- `W = 10`
- `Q = 12`
- `E = 9`
- `R = 9`

</td>
</tr>
</table>

---

<table>
<tr>
<td valign="top" width="87%">

如果有多個字元出現次數比需求的多，要找的字串就會隨之變化，以右邊例子來說，就是要找包含一個`W`，以及兩個`Q`的字串。\
這樣就跟[[76]]的做法相同，要找到包含指定字串的最短字串。
</td>
<td>

- `W = 11`
- `Q = 12`
- `E = 8`
- `R = 9`

</td>
</tr>
</table>

## 程式碼
### 滑動窗口
```cpp
class Solution {
private:
    int getID(char ch) {
        if(ch == 'Q') return 0;
        else if(ch == 'W') return 1;
        else if(ch == 'E') return 2;
        else if(ch == 'R') return 3;
        return -1;
    }
public:
    int balancedString(string s) {
        int n = s.length();

        // 1. 統計字元出現次數
        int cnt[4]{};        
        for(int i = 0; i < n; ++i) {
            cnt[getID(s[i])]++;
        }
        
        // 2. 債務表更新
        int m = n / 4;
        int debt = 0;
        for(int i = 0; i < 4; i++) {
            cnt[i] = min(0, m - cnt[i]); // 如果比 m 多, 相減是負數, 代表欠，比 m 少會是 0, 代表沒欠
            debt -= cnt[i]; // 如果有欠債, cnt[i] 是負數, 所以用減的
        }
        if(debt == 0) return 0; // 沒有債務，不需要修改字串

        // 3. 找到最短字串
        int res = n;
        for(int i = 0, j = 0; j < n; j++) {
            if(cnt[getID(s[j])]++ < 0) { // 還債 
                debt--; // 還的字元的確是需要的
            }
            if(debt == 0) {
                while(cnt[getID(s[i])] > 0) { // 左邊界的字元有盈餘
                    cnt[getID(s[i++])]--; // 移動左邊界
                }
                res = min(res, j - i + 1);
            }
        }
        return res;
    }
};
```
## 複雜度分析
- 時間複雜度：$O(n)$
- 空間複雜度：$O(1)$

