---
category: "leetcode"

title: "958. 二叉樹的完全性檢驗"
en_title: "958. Check Completeness of a Binary Tree"

problem_id: "958"
difficulty: "medium"
tags: ["tree", "bfs", "binary tree"]

link: "https://leetcode.cn/problems/check-completeness-of-a-binary-tree/"
en_link: "https://leetcode.com/problems/check-completeness-of-a-binary-tree/"
date: "2026-01-10"
---
## 思路
一個完全二叉樹，除了最後一列外，每一列的節點都要是滿的，最後一列如果不是滿的，則最後一列的節點應該要盡量靠左。判斷依據如下\

<table>
<tr>
<td width="75%">

1. 對每個節點判斷是否「有右無左」，假如沒有左邊的節點，相當於空了一塊。
2. 如果遇到子節點為空的節點，則後續的點都必須要是葉節點。

滿足以上條件，就是一個完全二叉樹。否則就不是\
以右圖舉例來說，當走到 5 時，發現有缺，那麼後面的節點都得是葉節點。

</td>
<td valign="top">

![圖片](../../assets/images/958.png)
</td>
</tr>
</table>

## 程式碼
### 1
```cpp
class Solution {
public:
    bool isCompleteTree(TreeNode* root) {
        const int MX = 1001;
        bool leaf = false;
        TreeNode* q[MX];
        int left = 0, right = 0;
        q[right++] = root;
        TreeNode* cur;
        while(left < right) {
            cur = q[left++];
            if(!cur->left && cur->right || (leaf && (cur->left || cur->right))) return false; // 有右無左 || 應該要是葉節點, 卻不是
            
            if(cur->left) q[right++] = cur->left;
            if(cur->right) q[right++] = cur->right;
            
            if(!cur->left || !cur->right) { // 有缺, 接下來的點都要是葉節點
                leaf = true;
            }
        }
        return true;
    }
};
```
## 複雜度分析
- 時間複雜度：$O(n)$
- 空間複雜度：$O(n)$

