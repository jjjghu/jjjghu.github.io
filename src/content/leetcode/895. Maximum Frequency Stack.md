---
category: "leetcode"

title: "895. 最大頻率棧"   
en_title: "895. Maximum Frequency Stack"

problem_id: "895"
difficulty: "hard"
tags: ["stack", "hash table", "ordered set"]

link: "https://leetcode.cn/problems/maximum-frequency-stack/"
en_link: "https://leetcode.com/problems/maximum-frequency-stack/"
date: "2026-01-05"
---
## 思路
題目要求實現`stack`的修改版。在`pop`時要彈出出現次數最多的數字，如果相同就選最近放入的。\
因此需要額外紀錄每個元素出現的頻率，並且為每一個頻率都單獨創一個`stack`出來。\
假如插入的資料是 $[a,b,b,a]$  ，會發生以下的事情：
1. 插入資料`a`
  - `freq[a] = 1`，發現`stks`沒有針對出現頻率`1`創建對應的棧，先創建。
  - `stks[freq[a]].push(a)`，將`a`放到對應的`stack`當中。
2. 插入資料`b`
  - `freq[b] = 1`，`stks`有創建對應的棧。
  - `stks[freq[b]].push(b)`，此時`stks[1] = {a, b}`
3. 插入資料`b`
  - `freq[b] = 2`，`stks`沒有創建對應的棧，先創建。
  - `stks[freq[b]].push(b)`，此時`stks[2] = {b}`
4. 連續插入兩次`a`，最後的樣子
  - `freq[a] = 3,` `freq[b] = 2`
  - `stks[3] = {a}`,`stks[2] = {b, a}`, `stks[1] = {a, b}`

---

如果`pop`，就取`stks.back()`（紀錄出現最多頻率的棧），並取得棧頂元素（最新資料）。\
舉例來說，在第三步之後`pop`，就會取到`stks[2].top() = b`

## 程式碼
### 棧
```cpp
class FreqStack {
private:
    unordered_map<int, int> freq; // 元素對應的出現頻率
    vector<stack<int>> stks; // 出現頻率對應的stack
public:
    FreqStack() {}
    void push(int val) {
        if(freq[val] == stks.size()) { // 需要新的 stack
            stks.push_back(stack<int>());
        }
        stks[freq[val]].push(val);
        freq[val]++;
    }
    
    int pop() {
        int val = stks.back().top();
        stks.back().pop();
        if(stks.back().empty()) {
            stks.pop_back();
        }
        freq[val]--;
        return val;
    }
};
```
## 複雜度分析
- 時間複雜度：$O(1)$。
- 空間複雜度：$O(q)$，$q$為 $\text{push}$ 的調用次數。

