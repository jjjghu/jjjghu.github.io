---
category: "leetcode"

title: "1390. 四因数"
en_title: "1390. Four Divisors"

problem_id: "1390"
difficulty: "medium"
tags: ["array", "math"]

link: "https://leetcode.cn/problems/four-divisors/"
en_link: "https://leetcode.com/problems/four-divisors/"
date: "2026-01-04"
---
## 思路
題目要找到有四個因數的數字，並將滿足條件的數字的所有因數相加。
而每個數字的因數都必定包含 1 跟自己，這樣就是兩個（1 是特例，但此題不需要考慮），
因此就是要先判斷這個數字能不能找到剛好一種的分解方式。
`x = a * b`，其中`a, b != 1` 且 `a, b != x`。

我們能用找質數的埃氏篩法，稍微修改之後用以找到因數合，以及共有多少因數。
舉例來說，現在要找`1 ~ 10`當中所有數字的因數合以及有多少因數。
用兩層迴圈，外層`i`，內層`j`。
`i = 1`, 這時`1 ~ 10`都是 1 的倍數。
`i = 2`，這時`2, 4, 6, 8, 10` 都是 2 的倍數。
`i = 3`，這時`3, 6, 9` 都是 3 的倍數。
`i = x`，這時`x, 2x, 3x ...`都是 i 的倍數。
因此用兩層迴圈計算出因數合與因數作為判斷依據。
題目有給數據範圍，因此在初始化的時候，立刻先將表格建立起來，以供後續查找。
## 程式碼
```c++
const int MX = 1e5;
int factor[MX + 1];
int factor_sum[MX + 1];
int init = []{
    for(int i = 1; i <= MX; ++i) { // 如果想要優化可以從 2 開始，不過答案那邊就要修改
        for(int j = i; j <= MX; j += i) {
            factor[j]++;
            factor_sum[j] += i;
        }
    }
    return 0;
}();
class Solution {
public:
    int sumFourDivisors(vector<int>& nums) {
        int res = 0;
        for(int num : nums) {
            if(factor[num] == 4) { // 如果篩選從 2 開始, 需要修改為 3,
                res += factor_sum[num]; // 同上，需要額外加 1
            }
        }
        return res;
    }
};
```
## 複雜度分析
- 時間複雜度：$O(MX\log{MX})$($MX + MX / 2 + MX / 3 + ...$)
- 空間複雜度：$O(MX)$
