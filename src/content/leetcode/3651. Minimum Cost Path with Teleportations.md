---
category: "leetcode"

title: "3651. 帶傳送的最小路徑成本"
en_title: "3651. Minimum Cost Path with Teleportations"

problem_id: "3651"
difficulty: "hard"
tags: ["shortest path", "heap", "dp"]

link: "https://leetcode.cn/problems/minimum-cost-path-with-teleportations/"
en_link: "https://leetcode.com/problems/minimum-cost-path-with-teleportations/"
date: "2026-01-28"
---
小貼士：第二個方法比較好，第一個方法主要是思考過程。
## Dijkstra
### 思路
最初直覺想到動態規劃，但因為題目允許傳送，且方向不固定，\
產生了「後無效性」，或是環的情況，打破了 DP 的計算順序。\
（雖然後面發現並不是這麼一回事）

最後打算用最短路徑演算法去解決這道問題，因為邊的權重沒有負數，用Dijkstra演算法。

為了處理「最多 $k$ 次傳送的限制」。
- 定義狀態`dist[x][y][k]`：代表走到座標$(x,y)$且使用了$k$次傳送的最小成本。
- Priority Queue：`{cost, x, y, used_k}`，按照 `cost` 從小到大排序。

有兩種擴展路徑的方式
1. 普通移動：往下或往右。
    - 成本：`cost + grid[x][y]`
    - 狀態變化：`used[k]`不變
2. 傳送移動：
    - 成本不變
    - 狀態變化：`used[k]++`
    - 需要找到滿足的目標點`target`，這個點的成本要比當前點小，如果暴力搜尋會超時。

- 優化一：排序跟雙指針
    - 將所有格子放入`sorted_cell`中，並按照成本從小到大排序。
    - 維護`ptrs`陣列，記錄每一層`used_k`目前在`sorted_cell`掃描到的位置。
    - 每次都掃描直到不滿足條件，因為拿出的節點成本只會越來越多，\
    能透過傳送訪問到的位置只會越來越靠後。如果上次可以訪問到的節點，\
    在排序好的列表當中在`pos`，那麼，在後來再度嘗試傳送時，\
    只需要從`pos`開始往後，直到成本要大於自己之後結束就好，\
    至於`pos`前面的所有節點, 就算現在選擇使用傳送過去，\
    當前的高成本也註定代表這條路徑不是最好的。 

- 優化二：
    - 問題：堆中可能存在同一個狀態的多種版本
    - 解法：從堆中取出的點，檢查是否比`dist`陣列中的數值大，如果比較大，表示為舊資料，不需進行後續計算。

- 優化三：
    - 問題：當傳送到`(nx, ny)`且狀態為`used_k + 1`時，\
    如果之前已經有「更少傳送次數」且成本更低的路徑到過這裡，那這次傳送就是浪費。
    - 解法：在把傳送結果加入堆前檢查。
### 程式碼
```cpp
class Solution {
public:
    int minCost(vector<vector<int>>& grid, int k) {
        using t4i = tuple<int, int, int, int>;
        int m = grid.size(), n = grid[0].size();
        vector<tuple<int, int, int>> sorted_cell; // cost, 座標
        priority_queue<t4i, vector<t4i>, greater<t4i>> pq; // cost, 座標, 技能使用次數
        for(int i = 0; i < m; ++i) {
            for(int j = 0; j < n; ++j) {
                sorted_cell.push_back(make_tuple(grid[i][j], i, j));
            }
        }
        ranges::sort(sorted_cell);
        pq.push(make_tuple(0, 0, 0, 0)); // 起點的成本不需要計算
        
        vector dist(m, vector(n, vector(k + 1, INT_MAX))); // dist[x][y][k] = cost
        dist[0][0][0] = 0;
        vector<int> ptrs(k + 1, 0); // 紀錄技能使用次數對應走訪到的位置
        while(!pq.empty()) {
            auto [cost, x, y, used_k] = pq.top(); pq.pop();
            if(cost > dist[x][y][used_k]) continue; // 優化二
            
            // 正常移動, 可以移動到自己的兩個鄰居
            if(x + 1 < m && dist[x + 1][y][used_k] > cost + grid[x + 1][y]) {
                dist[x + 1][y][used_k] = cost + grid[x + 1][y];
                pq.push(make_tuple(cost + grid[x + 1][y], x + 1, y, used_k));
            }
            if(y + 1 < n && dist[x][y + 1][used_k] > cost + grid[x][y + 1]) {
                dist[x][y + 1][used_k] = cost + grid[x][y + 1];
                pq.push(make_tuple(cost + grid[x][y + 1], x, y + 1, used_k));
            }
            
            // 傳送移動
            if(used_k + 1 <= k) { // 還可以用技能
                while(ptrs[used_k] < m * n) { // 指針還可以往前走
                    auto [_, nx, ny] = sorted_cell[ptrs[used_k]];
                    // 優化三：檢查 dist[nx][ny][0...used_k] 的最小值
                    if(ranges::min(dist[nx][ny] | views::take(used_k + 1)) <= dist[x][y][used_k]) {
                        ptrs[used_k]++;
                        continue;
                    }
                    if(grid[nx][ny] <= grid[x][y]) {
                        if(dist[nx][ny][used_k + 1] > dist[x][y][used_k]) {
                            dist[nx][ny][used_k + 1] = dist[x][y][used_k];
                            pq.push(make_tuple(dist[nx][ny][used_k + 1], nx, ny, used_k + 1));
                        }
                        ptrs[used_k]++;
                    }
                    else { // 當前指針的成本大過自己，無法傳送
                        break;
                    }
                }
            }
        }
        return ranges::min(dist[m - 1][n - 1]);
    }
};
```
### 複雜度分析
- 時間複雜度：$O(mn\times \max_{k}\times \log(mn\times \max_{k}))$
- 空間複雜度：$O(mn\times \max_{k})$
